extends layout/layout-pages
block hero
  h1 Framework
  p
   | Unlike other Continuous Integration tools, buildbot gives you a framework to build your own process
  p
   strong Your workflow
   |  is shaping the tool, and not the other way around
block text
  :markdown
    Many CI packages, such as [CruiseControl](http://cruisecontrol.sourceforge.net/gettingstarted.html) or
    [Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins),
    are structured as ready-to-use applications. Users
    fill in specific details, such as version control information and build
    process, but the fundamental design is fixed and options are limited to
    those envisioned by the authors. This arrangement suits the common cases
    quite well: there are cookie-cutter tools to automatically build and
    test Java applications, Ruby gems, and so on. Such tools embody
    assumptions about the structure of the project and its processes. They
    are not well-suited to more complex cases, such as mixed-language
    applications or complex release tasks, where those assumptions are
    violated.

    In contrast, Buildbot is designed as a framework: it provides tools for
    continuous integration and release management, allowing users to
    implement a system that suits their needs within that structure. While
    this makes Buildbot particularly well-suited to implementing the complex
    requirements of release engineering, it is consequently not as easy to
    get started as with some other CI applications.

    Configuration Interface
    -----------------------

    Buildbot does not support web-based configuration, and requires the user
    to edit the sample configuration file before the first run. This
    approach follows the UNIX philosophy of explicit, editable
    configuration—many Buildbot users keep their configuration in version
    control—and enables very expressive configuration. In contrast, after
    installation, the Jenkins web interface invites the user to add a
    project via the web interface—no configuration file is visible to the
    user. The Buildbot community has discussed support for web-based
    configuration, e.g.[Mark Garboden's *Buildbot config wizard*] (http://comments.gmane.org/gmane.comp.python.buildbot.devel/554),
    but no robust implementation has emerged.

    Batteries Included
    ------------------

    Jenkins, like many CI applications, ships with limited capabilities, and
    uses a [plug-in architecture](https://wiki.jenkins-ci.org/display/JENKINS/Plugins) to add additional
    capabilities. In contrast, Buildbot includes many useful components in
    the base package, and does not rely on plug-ins. These tools address
    common needs such as version-control integration, specialized build
    tools, and flexible status reporting. In many cases, the first
    implementation of Buildbot in an organization can use the built-in
    components, only replacing them with customized implementations as the
    requirements grow. This approach mirrors Python’s notion of a "Batteries
    Included" language.

    Pull vs. Push
    -------------

    Job-queueing systems fall into two categories: push, where the central
    scheduler sends jobs to a worker it knows to be idle; and pull, where
    workers request jobs from the central scheduler. Tools like
    [Tinderbox](https://developer.mozilla.org/en-US/docs/Tinderbox)
    operate on a pull model, where each tinderbox builds
    the latest revision in a tight loop, reporting status to the central
    tinderbox server. CruisControl and Jenkins support both models. Buildbot
    operates exclusively on a push model: slaves simply perform the
    operations they receive from the master, and report the results. The
    advantage of Buidbot’s approach is that configuration is centralized on
    the masters. However, it is not well-suited to cases where slave
    resources also serve other purposes, as the Buildbot master lacks the
    context to determine if a slave is ready to perform a build.

    Advanced Buildbot Configuration
    ===============================

    This section highlights some of Buildbot’s high-level capabilities. It
    focuses on capabilities that are useful in release management and
    operation at scale.

    Expressive Configuration
    ------------------------

    Buildbot’s configuration file is a Python script. While a basic
    configuration can be written with little knowledge of Python, ready
    access to Python’s power makes programmatic configuration trivial. For
    example, a configuration with several identical Windows slaves might
    include this snippet to automatically generate each slave configuration:

        for n in range(0, 20):
          c['slaves'].append(
            BuildSlave('win-slave%d' % n, PASSWD))

    All of the concepts introduced above–change sources, schedulers, slaves,
    builders, and status listeners–can be configured in this Python script.
    Basic configurations can use the built-in support, while more advanced
    configurations include custom implementations.

    Builder configurations include a list of steps to execute for each build
    (a *build factory*). The steps can be simple shell commands, built-in
    source-checkout or build commands, or custom implementations. Steps can
    use and modify the build’s properties, treating them as variables to
    coordinate the progress of the build.

    Buildbot supports dynamic reconfiguration without interrupting running
    builds. This allows adjustments to the build process without downtime.

    Having buildbot configuration as a Python script allow users to put it in
    configuration management (e.g. git), and thus easily revert track changes,
    in a team environment. Release engineers can develop their config changes
    in their own environment, and then push the results in production.

    Multiple Codebases
    ------------------

    Buildbot supports the increasingly common practice of building
    applications from multiple codebases. For example, a mobile application
    might have an "Android" codebase, an "iOS" codebase, and a "Common"
    codebase containing assets common to both implementations, with each
    codebase in a different repository. Buildbot can monitor all three
    repositories, and schedule android builds with source stamps from the
    "Android" and "Common" codebases when either one changes; likewise for
    "iOS". Status is reported for the resulting multidimensional revision
    space.

    Scaling and Resiliency
    ----------------------

    Large-scale buildbot deployments run with both masters and slaves in a
    clustered configuration. The masters use a shared relational database
    (MySQL or Postgres) to coordinate their actions. Multiple
    identically-configured slaves allow parallel execution of the same type
    of build for high-volume deployments, and resiliency to slave failure.

    In a cluster, the same slave can be configured on multiple masters, and
    that slave can connect to any one of the masters. Assuming all masters
    are configured with the same builders, this allows resiliency to the
    failure of a master. The masters share the load of processing status and
    logs, which can be substantial in a very busy cluster.

    As an extreme example of Buildbot at scale, Mozilla’s Buildbot
    deployment is comprised of tens of masters and thousands of slaves. It
    performed 137 hours of build and test per checkin, with a checkin every
    6 minutes, [as of August 2012](http://oduinn.com/blog/2012/08/21/137-hours-compute-hours-every-6-minutes/).

    Only some of Buildbot’s data is stored in the database. The remainder is
    stored in on-disk "pickle" files, as marshaled Python objects. Handling
    these pickles is inefficient, generating high IO load on the masters and
    slowing processing considerably. More critically, the data on one
    master’s disk is not accessible from another master, so analyzing builds
    distributed across a cluster is difficult.
    Section [sec:ongoing-developments] describes ongoing work to address
    these shortcomings.

    Artifact Handling
    -----------------

    For a continuous-integration build, the important result is essentially
    boolean: did the build or tests fail? For a release, the output is a set
    of binary artifacts—usually packages—ready for installation by
    end-users.

    Buildbot includes support for a few common package formats, although in
    most cases the package-building process is driven by a project-specific
    script. Binary artifacts are generated on slaves as part of a build, and
    are then transmitted somewhere to make them accessible to users (or to
    the quality assurance team in a larger organization).

    Artifact upload steps are included with Buildbot, but the steps transfer
    the file data using a particularly inefficient mechanism (RPC, rather
    than a streaming protocol). For any but the smallest installations, they
    are inadequate, performing poorly and causing performance issues for
    other builds on the same master. Most installations use SSH (via scp) or
    authenticated HTTP instead, implemented in a shell command.

    The Buildbot community has [discussed](https://github.com/buildbot/buildbot/pull/547)
    integration with external tools, but no compelling implementation has yet emerged.

    Build Coordination
    ------------------

    It is often desirable to perform multiple operations in parallel. This
    can drastically reduce the end-to-end time (the time between a commit
    and completion of the last resulting job), and save a great deal of
    redundant computation.

    Because Buildbot runs each build on a single slave, parallel operations
    must be represented as multiple builds. In programming-language terms,
    builds form the *basic block* from which more complex control flows are
    constructed. The remaining operations are to "branch" control into
    multiple builds, and then "merge" control back when those builds are
    complete.

    The branching operation is accomplished by configuring a scheduler to
    queue build requests for multiple builders. The resulting set of build
    requests comprise a *build set* and can be executed in parallel. If
    slave resources are limited, then the resulting builds may not actually
    execute concurrently, but they will be prioritized by Buildbot’s
    multi-level priority configuration. This technique provides a simple way
    to branch the control flow, but does not provide a way to perform some
    further action after all builds are complete.

    Buildbot provides two mechanisms for more sophisticated coordination:
    the Dependent scheduler, and the Triggerable scheduler. The Dependent
    scheduler is configured to watch exactly one "upstream" scheduler. When
    all builds in a buildset initiated by the upstream scheduler complete
    sucessfully, the Dependent scheduler initiates its own set of builds.
    For example, a Dependent scheduler might be used to schedule several
    test builds after all compilation builds are complete, allowing multiple
    test builds to share the same compiled artifacts.

    The Triggerable scheduler initiates builds for its configured builders
    when triggered by a step in another build. That step can either wait for
    the triggered builds to complete, or continue immediately. Waiting for
    the triggered builds provides a flexible method of merging control flow.
    In a relase build, for example, a Triggerable scheduler could be used to
    build localized versions of the application, with one build per locale,
    triggered by the a step in the compile build for each platform.

    The most complex control flows are implemented as a single controlling
    build which triggers the necessary builds in sequence. For example, such
    a build might trigger "compile" builds, followed by "test" builds if
    compile is successful, and followed by "package" builds, with each
    initiating builds on different slaves.

    Buildbot has ample room for improvement in support for build
    coordination: the frameworke provides no convenient means to summarize
    the output of a process that is spread over multiple builds; unusual
    branch and merge conditions, such as continuing when 80% of locales
    build successfully, are difficult to implement; and a controlling build
    must be assigned to a slave, even though it never performs any
    operations on that slave.

    In general, creating a concurrent build process is similar
    assembly-language programming, in that high-level constructs are not
    available. Ideally, Buildbot would make common structures like
    functions, loops, and conditionals available to users to structure these
    operations. This is an as-yet unexplored area for future work.
